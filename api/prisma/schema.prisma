generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                     String         @id @default(cuid())
  createdAt              DateTime       @default(now())
  updatedAt              DateTime       @updatedAt
  email                  String         @unique
  password               String
  firebaseUid            String?        @unique
  name                   String
  birthDate              DateTime
  gender                 Gender
  interestedIn           Gender[]
  bio                    String?
  education              String?
  profession             String?
  height                 String?
  relationshipType       String?
  religion               String?
  smoking                String?
  drinking               String?
  travel                 String?
  pets                   String?
  location               String?
  latitude               Float?
  longitude              Float?
  mainPhotoId            String?
  isActive               Boolean        @default(true)
  isPremium              Boolean        @default(false)
  hasCompletedOnboarding Boolean        @default(false)
  onboardingStep         Int            @default(1)
  lastActive             DateTime       @default(now())
  profileViews           Int            @default(0)
  totalLikes             Int            @default(0)
  totalMatches           Int            @default(0)
  matchesAsUser1         Match[]        @relation("user1Matches")
  matchesAsUser2         Match[]        @relation("user2Matches")
  receivedMessages       Message[]      @relation("receivedMessages")
  sentMessages           Message[]      @relation("sentMessages")
  notifications          Notification[]
  photos                 Photo[]        @relation("userPhotos")
  reportsReceived        Report[]       @relation("reportedUser")
  reportsFiled           Report[]       @relation("reportingUser")
  subscriptions          Subscription[]
  actionsReceived        UserAction[]   @relation("actionsReceived")
  actionsSent            UserAction[]   @relation("actionsSent")
  interests              UserInterest[]
  mainPhoto              Photo?         @relation("mainPhoto", fields: [mainPhotoId], references: [id], onDelete: SetNull)

  @@map("users")
}

model Photo {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  userId          String
  url             String
  order           Int      @default(0)
  isMain          Boolean  @default(false)
  user            User     @relation("userPhotos", fields: [userId], references: [id], onDelete: Cascade)
  userAsMainPhoto User[]   @relation("mainPhoto")

  @@map("photos")
}

model UserAction {
  id         String     @id @default(cuid())
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  senderId   String
  receiverId String
  action     ActionType
  timestamp  DateTime   @default(now())
  receiver   User       @relation("actionsReceived", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     User       @relation("actionsSent", fields: [senderId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@map("user_actions")
}

model Match {
  id                String    @id @default(cuid())
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  user1Id           String
  user2Id           String
  isActive          Boolean   @default(true)
  matchedAt         DateTime  @default(now())
  lastMessage       String?
  lastMessageTime   DateTime?
  lastMessageBy     String?
  lastViewedByUser1 DateTime?
  lastViewedByUser2 DateTime?
  user1             User      @relation("user1Matches", fields: [user1Id], references: [id], onDelete: Cascade)
  user2             User      @relation("user2Matches", fields: [user2Id], references: [id], onDelete: Cascade)
  messages          Message[]

  @@unique([user1Id, user2Id])
  @@map("matches")
}

model Message {
  id          String      @id @default(cuid())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  matchId     String
  senderId    String
  receiverId  String
  content     String
  messageType MessageType @default(TEXT)
  isRead      Boolean     @default(false)
  readAt      DateTime?
  isDelivered Boolean     @default(false)
  deliveredAt DateTime?
  mediaUrl    String?
  mediaType   String?
  match       Match       @relation(fields: [matchId], references: [id], onDelete: Cascade)
  receiver    User        @relation("receivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)
  sender      User        @relation("sentMessages", fields: [senderId], references: [id], onDelete: Cascade)

  @@map("messages")
}

model Interest {
  id            String         @id @default(cuid())
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  name          String         @unique
  category      String?
  description   String?
  isActive      Boolean        @default(true)
  userInterests UserInterest[]

  @@map("interests")
}

model UserInterest {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  userId     String
  interestId String
  interest   Interest @relation(fields: [interestId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, interestId])
  @@map("user_interests")
}

model Notification {
  id        String           @id @default(cuid())
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?
  isRead    Boolean          @default(false)
  readAt    DateTime?
  isSent    Boolean          @default(false)
  sentAt    DateTime?
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model Subscription {
  id                   String             @id @default(cuid())
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  userId               String
  plan                 SubscriptionPlan
  status               SubscriptionStatus
  startDate            DateTime
  endDate              DateTime
  autoRenew            Boolean            @default(true)
  stripeSubscriptionId String?            @unique
  stripeCustomerId     String?
  amount               Float
  currency             String             @default("USD")
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model Report {
  id           String       @id @default(cuid())
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  reporterId   String
  reportedId   String
  reason       ReportReason
  description  String?
  status       ReportStatus @default(PENDING)
  reviewedBy   String?
  reviewedAt   DateTime?
  adminNotes   String?
  reportedUser User         @relation("reportedUser", fields: [reportedId], references: [id], onDelete: Cascade)
  reporter     User         @relation("reportingUser", fields: [reporterId], references: [id], onDelete: Cascade)

  @@map("reports")
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
  OTHER
}

enum ActionType {
  LIKE
  PASS
  SUPER_LIKE
  UNDO
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  LOCATION
  STICKER
}

enum NotificationType {
  NEW_MATCH
  NEW_MESSAGE
  PROFILE_VIEW
  SUPER_LIKE
  SUBSCRIPTION_EXPIRING
  SUBSCRIPTION_RENEWED
  SYSTEM_ANNOUNCEMENT
}

enum SubscriptionPlan {
  BASIC
  PREMIUM
  PREMIUM_PLUS
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PAST_DUE
  PAUSED
}

enum ReportReason {
  INAPPROPRIATE_PHOTOS
  HARASSMENT
  SPAM
  FAKE_PROFILE
  UNDERAGE
  OTHER
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}
