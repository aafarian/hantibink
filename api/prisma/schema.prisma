// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model - Core user profile information
model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Authentication fields
  email       String  @unique
  password    String
  firebaseUid String? @unique // For migration from Firebase Auth

  // Basic profile information
  name         String
  birthDate    DateTime
  gender       Gender
  interestedIn Gender[]

  // Profile details
  bio              String?
  education        String?
  profession       String?
  height           String?
  relationshipType RelationshipType?
  religion         String?
  smoking          SmokingPreference?
  drinking         DrinkingPreference?
  travel           String?
  pets             String?

  // Location
  location  String?
  latitude  Float?
  longitude Float?

  // Photos
  photos      Photo[]
  mainPhotoId String?
  mainPhoto   Photo?  @relation("MainPhoto", fields: [mainPhotoId], references: [id], onDelete: SetNull)

  // Interests (many-to-many relationship)
  interests UserInterest[]

  // Profile status
  isActive               Boolean  @default(true)
  isPremium              Boolean  @default(false)
  hasCompletedOnboarding Boolean  @default(false)
  onboardingStep         Int      @default(1)
  lastActive             DateTime @default(now())

  // Statistics
  profileViews Int @default(0)
  totalLikes   Int @default(0)
  totalMatches Int @default(0)

  // Relationships
  sentActions      UserAction[]   @relation("ActionSender")
  receivedActions  UserAction[]   @relation("ActionReceiver")
  sentMatches      Match[]        @relation("MatchUser1")
  receivedMatches  Match[]        @relation("MatchUser2")
  sentMessages     Message[]      @relation("MessageSender")
  receivedMessages Message[]      @relation("MessageReceiver")
  reportsMade      Report[]       @relation("ReportReporter")
  reportsReceived  Report[]       @relation("ReportReported")
  subscriptions    Subscription[]
  notifications    Notification[]

  @@map("users")
}

// Photo model - User photos
model Photo {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  url    String
  order  Int     @default(0)
  isMain Boolean @default(false)

  // Reverse relation for main photo
  mainPhotoUsers User[] @relation("MainPhoto")

  @@map("photos")
}

// Interest model - Predefined interests
model Interest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name        String  @unique
  category    String?
  description String?
  isActive    Boolean @default(true)

  // Relationships
  users UserInterest[]

  @@map("interests")
}

// Junction table for User-Interest many-to-many relationship
model UserInterest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  interestId String
  interest   Interest @relation(fields: [interestId], references: [id], onDelete: Cascade)

  @@unique([userId, interestId])
  @@map("user_interests")
}

// UserAction model - Likes, passes, super likes
model UserAction {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  senderId   String
  sender     User   @relation("ActionSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId String
  receiver   User   @relation("ActionReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  action    ActionType
  timestamp DateTime   @default(now())

  @@unique([senderId, receiverId])
  @@map("user_actions")
}

// Match model - When two users like each other
model Match {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user1Id String
  user1   User   @relation("MatchUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2Id String
  user2   User   @relation("MatchUser2", fields: [user2Id], references: [id], onDelete: Cascade)

  // Match metadata
  isActive  Boolean  @default(true)
  matchedAt DateTime @default(now())

  // Last message info for quick access
  lastMessage     String?
  lastMessageTime DateTime?
  lastMessageBy   String?

  // Read status tracking
  lastViewedByUser1 DateTime?
  lastViewedByUser2 DateTime?

  // Relationships
  messages Message[]

  @@unique([user1Id, user2Id])
  @@map("matches")
}

// Message model - Chat messages between matched users
model Message {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  matchId String
  match   Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)

  senderId   String
  sender     User   @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId String
  receiver   User   @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  content     String
  messageType MessageType @default(TEXT)

  // Message status
  isRead      Boolean   @default(false)
  readAt      DateTime?
  isDelivered Boolean   @default(false)
  deliveredAt DateTime?

  // Media attachments (for future use)
  mediaUrl  String?
  mediaType String?

  @@map("messages")
}

// Report model - User reports for inappropriate behavior
model Report {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reporterId String
  reporter   User   @relation("ReportReporter", fields: [reporterId], references: [id], onDelete: Cascade)
  reportedId String
  reported   User   @relation("ReportReported", fields: [reportedId], references: [id], onDelete: Cascade)

  reason      ReportReason
  description String?
  status      ReportStatus @default(PENDING)

  // Admin fields
  reviewedBy String?
  reviewedAt DateTime?
  adminNotes String?

  @@map("reports")
}

// Subscription model - Premium subscriptions
model Subscription {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  plan      SubscriptionPlan
  status    SubscriptionStatus
  startDate DateTime
  endDate   DateTime
  autoRenew Boolean            @default(true)

  // Payment info
  stripeSubscriptionId String? @unique
  stripeCustomerId     String?
  amount               Float
  currency             String  @default("USD")

  @@map("subscriptions")
}

// Notification model - Push notifications and in-app notifications
model Notification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type    NotificationType
  title   String
  message String
  data    Json? // Additional data as JSON

  isRead Boolean   @default(false)
  readAt DateTime?
  isSent Boolean   @default(false)
  sentAt DateTime?

  @@map("notifications")
}

// Enums
enum Gender {
  MALE
  FEMALE
  NON_BINARY
  OTHER
}

enum RelationshipType {
  CASUAL
  SERIOUS
  FRIENDSHIP
  MARRIAGE
}

enum SmokingPreference {
  NEVER
  OCCASIONALLY
  REGULARLY
  PREFER_NOT_TO_SAY
}

enum DrinkingPreference {
  NEVER
  OCCASIONALLY
  SOCIALLY
  REGULARLY
  PREFER_NOT_TO_SAY
}

enum ActionType {
  LIKE
  PASS
  SUPER_LIKE
  UNDO
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  LOCATION
  STICKER
}

enum ReportReason {
  INAPPROPRIATE_PHOTOS
  HARASSMENT
  SPAM
  FAKE_PROFILE
  UNDERAGE
  OTHER
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

enum SubscriptionPlan {
  BASIC
  PREMIUM
  PREMIUM_PLUS
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PAST_DUE
  PAUSED
}

enum NotificationType {
  NEW_MATCH
  NEW_MESSAGE
  PROFILE_VIEW
  SUPER_LIKE
  SUBSCRIPTION_EXPIRING
  SUBSCRIPTION_RENEWED
  SYSTEM_ANNOUNCEMENT
}
